# Rate Limiter - Desafio TÃ©cnico FullCycle

[![Go Version](https://img.shields.io/badge/Go-1.23-blue.svg)](https://golang.org)
[![Tests](https://img.shields.io/badge/tests-67%20passing-brightgreen.svg)](https://github.com)
[![Coverage](https://img.shields.io/badge/coverage-93.5%25-brightgreen.svg)](https://github.com)
[![Architecture](https://img.shields.io/badge/pattern-Strategy-orange.svg)](https://refactoring.guru/design-patterns/strategy)

Middleware HTTP para controle de taxa de requisiÃ§Ãµes (rate limiting) desenvolvido em Go, com suporte a limitaÃ§Ã£o por IP e por token de API.

## ğŸ“‹ CaracterÃ­sticas

- âœ… **Rate limiting por IP**: Limita requisiÃ§Ãµes baseado no endereÃ§o IP do cliente
- âœ… **Rate limiting por API Key**: Limites independentes para requisiÃ§Ãµes autenticadas
- âœ… **Bloqueio automÃ¡tico**: IPs que excedem o limite sÃ£o bloqueados temporariamente
- âœ… **Cleanup automÃ¡tico**: Remove dados antigos periodicamente para gerenciar memÃ³ria
- âœ… **Thread-safe**: Implementado com `sync.RWMutex` para operaÃ§Ãµes concorrentes
- âœ… **Graceful shutdown**: Suporte a context para parada controlada
- âœ… **ConfigurÃ¡vel**: Todos os parÃ¢metros via variÃ¡veis de ambiente
- âœ… **Suporte a proxies**: Detecta IP real via header `X-Forwarded-For` (load balancers, CDN)
- âœ… **IPv4 e IPv6**: Suporte completo para ambos protocolos
- âœ… **Strategy Pattern**: Backend plugÃ¡vel com interface para mÃºltiplas implementaÃ§Ãµes
- âœ… **In-memory storage**: Armazenamento local de alta performance
- âœ… **Redis storage**: Backend Redis com serializaÃ§Ã£o JSON e thread-safety
- âœ… **ExtensÃ­vel**: FÃ¡cil adiÃ§Ã£o de novos backends (PostgreSQL, DynamoDB, etc.)

## ğŸš€ InstalaÃ§Ã£o

### PrÃ©-requisitos

- Go 1.23 ou superior
- Git
- Redis (opcional, apenas se usar RedisBackend)

### Clonar o repositÃ³rio

```bash
git clone https://github.com/seu-usuario/rate-limiter.git
cd rate-limiter
```

### Instalar dependÃªncias

```bash
go mod download
```

## âš™ï¸ ConfiguraÃ§Ã£o

Copie o arquivo de exemplo para criar seu `.env`:

```bash
cp cmd/server/.env_example cmd/server/.env
```

Edite `cmd/server/.env` conforme necessÃ¡rio:

```env
# ConfiguraÃ§Ãµes do Server
SERVER_PORT=:8080

# ConfiguraÃ§Ãµes de Rate Limiting por IP
RATE_LIMITER_MAX_REQUESTS=5
RATE_LIMITER_TIME_DELAY=20s

# ConfiguraÃ§Ãµes de Rate Limiting por Token
RATE_LIMITER_TOKEN_MAX_REQUESTS=7
RATE_LIMITER_TOKEN_TIME_DELAY=10s

# ConfiguraÃ§Ãµes de Cleanup AutomÃ¡tico
RATE_LIMITER_CLEANUP_INTERVAL=30s
RATE_LIMITER_TTL=2m

# ConfiguraÃ§Ã£o do Backend Para Redis (opcional caso use Memory)
RATE_LIMITER_REDIS_ADDR=localhost:6379
```

### VariÃ¡veis de Ambiente

| VariÃ¡vel | DescriÃ§Ã£o | Exemplo | PadrÃ£o |
|----------|-----------|---------|--------|
| `SERVER_PORT` | Porta do servidor | `:8080` | - |
| `RATE_LIMITER_MAX_REQUESTS` | NÃºmero mÃ¡ximo de requisiÃ§Ãµes por IP | `100` | - |
| `RATE_LIMITER_TIME_DELAY` | Tempo de bloqueio apÃ³s exceder limite (IP) | `60s`, `5m`, `1h` | - |
| `RATE_LIMITER_TOKEN_MAX_REQUESTS` | NÃºmero mÃ¡ximo de requisiÃ§Ãµes por token | `200` | - |
| `RATE_LIMITER_TOKEN_TIME_DELAY` | Tempo de bloqueio apÃ³s exceder limite (token) | `60s`, `5m`, `1h` | - |
| `RATE_LIMITER_CLEANUP_INTERVAL` | Intervalo de execuÃ§Ã£o do cleanup | `10m`, `30m`, `1h` | - |
| `RATE_LIMITER_TTL` | Tempo de vida dos dados antes da limpeza | `1h`, `2h`, `24h` | - |
| `RATE_LIMITER_REDIS_ADDR` | EndereÃ§o do servidor Redis | `localhost:6379` | - |

### Formatos de DuraÃ§Ã£o

O projeto aceita duraÃ§Ãµes no formato Go:
- `s` - segundos (ex: `30s`)
- `m` - minutos (ex: `5m`)
- `h` - horas (ex: `1h`)
- Combinados (ex: `1h30m`, `2h45m30s`)

## ğŸƒ Como Usar

### ğŸ³ Com Docker Compose (Recomendado)

A forma mais fÃ¡cil de testar o projeto Ã© usando Docker Compose, que sobe automaticamente a aplicaÃ§Ã£o e o Redis:

```bash
# Subir todos os serviÃ§os (app + Redis + Redis Commander)
docker-compose up -d

# Ver logs
docker-compose logs -f app

# Parar todos os serviÃ§os
docker-compose down
```

ServiÃ§os disponÃ­veis:
- **AplicaÃ§Ã£o**: http://localhost:8080
- **Redis Commander** (interface web): http://localhost:8081

### ğŸ’» Executar localmente

Se preferir executar sem Docker:

```bash
# Desenvolvimento
go run cmd/server/main.go

# Build e execuÃ§Ã£o
go build -o server cmd/server/main.go
./server
```

> **Nota**: Se o projeto estiver configurado para usar Redis (`ratelimiter.Redis` no `main.go`), vocÃª precisarÃ¡ ter o Redis rodando localmente ou via Docker.

### IntegraÃ§Ã£o em seu cÃ³digo

```go
package main

import (
    "adalbertofjr/desafio-rate-limiter/ajun"
    "adalbertofjr/desafio-rate-limiter/ajun/middleware/ratelimiter"
    "adalbertofjr/desafio-rate-limiter/cmd/configs"
    "adalbertofjr/desafio-rate-limiter/internal/infra/api"
    "context"
    "fmt"
    "net/http"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // Carregar configuraÃ§Ãµes do .env
    config, err := configs.LoadConfig(".")
    if err != nil {
        panic(err)
    }

    // Criar configuraÃ§Ã£o do rate limiter
    rateLimiterConfig := ratelimiter.NewRateLimiterConfig(
        config.RateLimiterMaxRequests,
        config.ParseTimerDuration(config.RateLimiterTimeDelay),
        config.RateLimiterTokenMaxRequests,
        config.ParseTimerDuration(config.RateLimiterTokenTimeDelay),
        ratelimiter.Memory,  // ou ratelimiter.Redis
        config.RateLimiterRedisAddr,
        config.ParseTimerDuration(config.RateLimiterCleanupInterval),
        config.ParseTimerDuration(config.RateLimiterTTL),
    )

    // Criar router e aplicar middleware
    ajunRouter := ajun.NewRouter(ctx)
    ajunRouter.RateLimiter(rateLimiterConfig)

    // Adicionar handlers (use os handlers do pacote api ou crie os seus)
    ajunRouter.HandleFunc("/health", api.HealthHandler)
    ajunRouter.HandleFunc("/products", api.ListProductsHandler)

    // Iniciar servidor
    fmt.Println("Starting web server on port", config.ServerPort)
    http.ListenAndServe(config.ServerPort, ajunRouter.Handler)
}
```

**Nota**: Os handlers estÃ£o em `internal/infra/api/handlers.go`. VocÃª pode usÃ¡-los diretamente ou criar seus prÃ³prios handlers.

### Alternar entre Memory e Redis

Para trocar o backend, edite `cmd/server/main.go` linha 25:

```go
// Backend Memory (em memÃ³ria)
ratelimiter.Memory,

// Ou Backend Redis
ratelimiter.Redis,
```

Certifique-se de configurar `RATE_LIMITER_REDIS_ADDR` no `.env` se usar Redis.

## ğŸ“¡ Testando o Rate Limiter

### Teste RÃ¡pido Manual

#### RequisiÃ§Ã£o sem API Key (limitada por IP)

```bash
curl http://localhost:8080/health
```

#### RequisiÃ§Ã£o com API Key (limitada por token)

```bash
curl -H "Api_key: seu-token-123" http://localhost:8080/products
```

#### Resposta quando bloqueado (429)

```
HTTP/1.1 429 Too Many Requests

You have reached the maximum number of requests or actions allowed within a certain time frame.
```

### ğŸ¯ Script de Teste Automatizado

O projeto inclui um script para simular mÃºltiplas requisiÃ§Ãµes e validar o bloqueio:

```bash
# Dar permissÃ£o de execuÃ§Ã£o
chmod +x scripts/test_rate_limit.sh

# Executar com valores padrÃ£o (30 requisiÃ§Ãµes, 0.1s intervalo)
./scripts/test_rate_limit.sh

# Personalizar nÃºmero de requisiÃ§Ãµes e intervalo
./scripts/test_rate_limit.sh 50 0.05
```

**SaÃ­da esperada:**

```
=========================================
Teste de Rate Limiter
=========================================
URL: http://localhost:8080/health
NÃºmero de requisiÃ§Ãµes: 30
Intervalo: 0.1s
=========================================

[14:23:10.123] RequisiÃ§Ã£o #1: âœ… 200 OK
[14:23:10.234] RequisiÃ§Ã£o #2: âœ… 200 OK
[14:23:10.345] RequisiÃ§Ã£o #3: âœ… 200 OK
[14:23:10.456] RequisiÃ§Ã£o #4: âœ… 200 OK
[14:23:10.567] RequisiÃ§Ã£o #5: âœ… 200 OK
[14:23:10.678] RequisiÃ§Ã£o #6: â›” 429 Too Many Requests
[14:23:10.789] RequisiÃ§Ã£o #7: â›” 429 Too Many Requests
...

=========================================
Resumo:
=========================================
Total de requisiÃ§Ãµes: 30
Sucesso (200): 5
Bloqueadas (429): 25
Taxa de bloqueio: 83.33%
=========================================
```

**ParÃ¢metros do script:**
- `$1`: NÃºmero de requisiÃ§Ãµes (padrÃ£o: 30)
- `$2`: Intervalo em segundos entre requisiÃ§Ãµes (padrÃ£o: 0.1)

**Dica:** Configure um limite baixo no `.env` (ex: `RATE_LIMITER_MAX_REQUESTS=5`) para ver o bloqueio acontecer mais rÃ¡pido.

**ğŸ’¡ Limpando o rate limit entre testes:**

Se vocÃª estiver bloqueado e quiser testar novamente, reinicie o app:

```bash
# Com Docker Compose
docker-compose restart app

# Ou executando localmente
# Ctrl+C e executar novamente
```

### ğŸŒ Teste com MÃºltiplos IPs

O projeto suporta `X-Forwarded-For` para ambientes com proxies/load balancers. Para testar com mÃºltiplos IPs simulados:

```bash
# Dar permissÃ£o
chmod +x scripts/test_multiple_ips.sh

# 15 requisiÃ§Ãµes distribuÃ­das entre 3 IPs diferentes
./scripts/test_multiple_ips.sh 15 3 0.1
```

**SaÃ­da esperada:**
```
IP 192.168.1.1: 2 OK | 3 Blocked | 60.0% bloqueio
IP 192.168.1.2: 2 OK | 3 Blocked | 60.0% bloqueio
IP 192.168.1.3: 1 OK | 4 Blocked | 80.0% bloqueio
```

Cada IP tem seu prÃ³prio limite independente, como ocorre em produÃ§Ã£o com load balancers.

**ParÃ¢metros:**
- `$1`: Total de requisiÃ§Ãµes (padrÃ£o: 100)
- `$2`: NÃºmero de IPs diferentes (padrÃ£o: 5)
- `$3`: Intervalo entre requisiÃ§Ãµes em segundos (padrÃ£o: 0.05)

### âš¡ Stress Test

Para teste de carga com requisiÃ§Ãµes concorrentes:

```bash
chmod +x scripts/stress_test.sh

# 10 processos fazendo 20 requisiÃ§Ãµes cada = 200 requisiÃ§Ãµes totais
./scripts/stress_test.sh 20 10
```

**SaÃ­da esperada:**
```
=========================================
Resultado do Stress Test:
=========================================
DuraÃ§Ã£o: 1s
RequisiÃ§Ãµes/segundo: 50.00

Total de requisiÃ§Ãµes: 50
Sucesso (200): 5
Bloqueadas (429): 45
Taxa de bloqueio: 90.00%
=========================================
```

**ParÃ¢metros:**
- `$1`: RequisiÃ§Ãµes por processo (padrÃ£o: 20)
- `$2`: NÃºmero de processos concorrentes (padrÃ£o: 10)

**Nota:** Se todas as requisiÃ§Ãµes aparecerem bloqueadas (100%), reinicie o app antes do teste.

## ğŸ—ï¸ Arquitetura

### Estrutura de DiretÃ³rios

```
.
â”œâ”€â”€ ajun/                         # Framework/Router customizado
â”‚   â”œâ”€â”€ ajun.go                   # Router wrapper
â”‚   â”œâ”€â”€ ajun_test.go              # Testes de integraÃ§Ã£o
â”‚   â””â”€â”€ middleware/
â”‚       â””â”€â”€ ratelimiter/
â”‚           â”œâ”€â”€ ratelimiter.go    # LÃ³gica principal do rate limiter
â”‚           â”œâ”€â”€ ratelimiter_test.go
â”‚           â”œâ”€â”€ storage.go        # Camada de storage com cleanup
â”‚           â”œâ”€â”€ storage_test.go   # Testes de storage
â”‚           â”œâ”€â”€ interface.go      # Backend interface (Strategy)
â”‚           â”œâ”€â”€ memory.go         # ImplementaÃ§Ã£o in-memory
â”‚           â”œâ”€â”€ memory_test.go    # Testes do backend memory
â”‚           â”œâ”€â”€ redis.go          # ImplementaÃ§Ã£o Redis
â”‚           â”œâ”€â”€ redis_test.go     # Testes do backend Redis
â”‚           â””â”€â”€ types.go          # ClientIPData struct
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ configs/
â”‚   â”‚   â””â”€â”€ configs.go            # Carregamento e validaÃ§Ã£o de configs
â”‚   â””â”€â”€ server/
â”‚       â”œâ”€â”€ main.go               # Entry point
â”‚       â””â”€â”€ .env_example          # Exemplo de configuraÃ§Ã£o
â”œâ”€â”€ internal/
â”‚   â””â”€â”€ infra/
â”‚       â””â”€â”€ api/
â”‚           â””â”€â”€ handlers.go       # HTTP handlers (health, products)
â”œâ”€â”€ api/
â”‚   â””â”€â”€ health.http               # Exemplos de requisiÃ§Ãµes HTTP
â””â”€â”€ scripts/
    â””â”€â”€ test_rate_limit.sh        # Script de teste de stress
```

### Componentes Principais

#### 1. **RateLimiter Middleware**

Intercepta requisiÃ§Ãµes HTTP e aplica controle de taxa baseado em:
- IP do cliente (`RemoteAddr`)
- Header `Api_key` (se presente)

#### 2. **Storage Layer**

Gerencia dados de rate limiting:
- Contador de requisiÃ§Ãµes por IP
- Timestamps de Ãºltima atividade
- Status de bloqueio (`DisableUntil`)
- IntegraÃ§Ã£o com backend via interface

#### 3. **Backend Interface (Strategy Pattern)**

Interface que define operaÃ§Ãµes de armazenamento:
```go
type Backend interface {
    Get(clientIP string) (*ClientIPData, error)
    Set(clientIP string, data *ClientIPData) error
    Delete(clientIP string) error
    List() (map[string]*ClientIPData, error)
    Clear() error
}
```

**ImplementaÃ§Ãµes disponÃ­veis:**
- `MemoryBackend`: In-memory com deep copy e thread-safety
- `RedisBackend`: Redis com serializaÃ§Ã£o JSON, mutex e miniredis para testes
- **Futuro**: `PostgreSQLBackend`, `DynamoDBBackend`, etc.

#### 4. **Cleanup Worker**

Goroutine background que executa periodicamente:
- Remove IPs sem atividade (baseado em TTL)
- Respeita bloqueios ativos
- Para gracefully com context

### Design Patterns

#### Strategy Pattern - Backend PlugÃ¡vel

O projeto implementa o **Strategy Pattern** para permitir diferentes estratÃ©gias de armazenamento sem alterar a lÃ³gica do rate limiter:

```go
// Interface Strategy
type Backend interface {
    Get(clientIP string) (*ClientIPData, error)
    Set(clientIP string, data *ClientIPData) error
    Delete(clientIP string) error
    List() (map[string]*ClientIPData, error)
}

// EstratÃ©gia Concreta 1: In-Memory
type MemoryBackend struct {
    mu   sync.RWMutex
    data map[string]*ClientIPData
}

// EstratÃ©gia Concreta 2: Redis
type RedisBackend struct {
    ctx    context.Context
    client *redis.Client
    mu     sync.RWMutex
}

// ObservaÃ§Ã£o: NewRedisBackend(ctx, "localhost:6379") cria o cliente internamente

// Context que usa a Strategy
type Storage struct {
    backend Backend  // <- ComposiÃ§Ã£o com interface
    // ... outros campos
}
```

**BenefÃ­cios:**
- âœ… **Open/Closed Principle**: Aberto para extensÃ£o, fechado para modificaÃ§Ã£o
- âœ… **Testabilidade**: Mock fÃ¡cil do backend para testes
- âœ… **Flexibilidade**: Trocar backend em runtime se necessÃ¡rio
- âœ… **SeparaÃ§Ã£o de responsabilidades**: Storage nÃ£o conhece detalhes de implementaÃ§Ã£o

**Como adicionar novo backend:**
```go
// 1. Implementar a interface Backend
type PostgreSQLBackend struct {
    db *sql.DB
}

func (p *PostgreSQLBackend) Get(clientIP string) (*ClientIPData, error) {
    // implementaÃ§Ã£o especÃ­fica do PostgreSQL
}
// ... implementar outros mÃ©todos

// 2. Usar no Storage
backend := NewPostgreSQLBackend(connStr)
storage := NewStorage(ctx, backend, cleanupInterval, ttl)

// Pronto! O resto do cÃ³digo continua funcionando
```

### Fluxo de Funcionamento

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Request   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RateLimiter        â”‚
â”‚  Middleware         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â–º Extrai IP
       â”œâ”€â–º Verifica Api_key header
       â”œâ”€â–º Incrementa contador
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Verifica se        â”‚
â”‚  estÃ¡ bloqueado     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â–º SIM: Retorna 429
       â”‚
       â””â”€â–º NÃƒO: Verifica limite
              â”‚
              â”œâ”€â–º Excedeu: Bloqueia + 429
              â”‚
              â””â”€â–º OK: Continua â”€â”€â–º Handler
```

## ğŸ§ª Testes

### Executar todos os testes

```bash
go test ./... -v
```

### Executar com cobertura

```bash
go test ./... -cover -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Executar com race detector

```bash
go test ./... -race
```

### Cobertura Atual

```
router:              100.0% âœ…
middleware/ratelimiter: 92.5% âœ…
storage:              79.7% âœ…
memory backend:       86.5% âœ…
redis backend:        78.4% âœ…
```

**Total: 67 testes**
- 11 testes de integraÃ§Ã£o (router)
- 32 testes unitÃ¡rios (ratelimiter)
- 12 testes de backend memory
- 12 testes de backend Redis (com miniredis)

**Benchmarks:**
- `BenchmarkMemoryBackend_Set`: ~35ns/op (0 alocaÃ§Ãµes)
- `BenchmarkMemoryBackend_Get`: ~22ns/op (0 alocaÃ§Ãµes)
- `BenchmarkMemoryBackend_ConcurrentSet`: ~202ns/op
- `BenchmarkMemoryBackend_ConcurrentGet`: ~110ns/op

### CenÃ¡rios Testados

- âœ… RequisiÃ§Ãµes abaixo do limite
- âœ… Bloqueio quando limite Ã© excedido
- âœ… Desbloqueio automÃ¡tico apÃ³s timeout
- âœ… IPs independentes
- âœ… ConcorrÃªncia (mÃºltiplas requisiÃ§Ãµes simultÃ¢neas)
- âœ… IPv4 e IPv6
- âœ… Limites diferentes para API Key
- âœ… Cleanup automÃ¡tico de dados antigos
- âœ… Graceful shutdown do cleanup worker
- âœ… Deep copy no backend para isolamento de dados
- âœ… Thread-safety testado com race detector
- âœ… Backend plugÃ¡vel via Strategy Pattern
- âœ… Redis backend com miniredis (testes sem servidor real)
- âœ… SerializaÃ§Ã£o/deserializaÃ§Ã£o JSON no Redis
- âœ… Clear() method para reset de dados nos testes

## ğŸ› ï¸ Desenvolvimento

### Tecnologias e PadrÃµes

- **Go 1.23**: Linguagem principal
- **Strategy Pattern**: Backend plugÃ¡vel e extensÃ­vel
- **sync.RWMutex**: Thread-safety com read/write locks
- **context.Context**: Controle de lifecycle e graceful shutdown
- **time.Ticker**: Cleanup periÃ³dico
- **Viper**: Gerenciamento de configuraÃ§Ãµes
- **httptest**: Testes HTTP
- **Deep Copy**: Isolamento de dados no backend
- **Redis**: Cliente go-redis/v9 com suporte a JSON
- **miniredis**: Mock in-memory do Redis para testes

### Executar em modo desenvolvimento

```bash
go run cmd/server/main.go
```

### Executar testes especÃ­ficos

```bash
# Apenas testes de middleware
go test ./ajun/middleware/ratelimiter -v

# Apenas testes do backend memory
go test ./ajun/middleware/ratelimiter -run TestMemoryBackend -v

# Apenas testes do backend Redis
go test ./ajun/middleware/ratelimiter -run TestRedis -v

# Teste especÃ­fico
go test ./ajun/middleware/ratelimiter -run TestRateLimiterHandler_BlocksRequestsAboveLimit -v

# Benchmarks do backend
go test ./ajun/middleware/ratelimiter -bench=BenchmarkMemoryBackend -benchmem
```

## ğŸ“Š Performance

### Benchmarks

```bash
go test ./ajun/middleware/ratelimiter -bench=. -benchmem
```

### Capacidade Estimada

- **Low-Medium traffic**: < 50k req/s âœ…
- **High traffic**: < 100k req/s âœ…
- **Very High traffic**: > 100k req/s (considerar Redis)

### OtimizaÃ§Ãµes Implementadas

- âœ… Mutex read/write separados (`RLock` vs `Lock`)
- âœ… Map lookup O(1)
- âœ… Cleanup assÃ­ncrono (nÃ£o bloqueia requisiÃ§Ãµes)
- âœ… Sem goroutines vazando (timer gerenciado)
- âœ… Deep copy apenas no `List()` (Get/Set sem alocaÃ§Ãµes extras)
- âœ… Backend interface sem overhead (chamadas diretas)
- âœ… Zero alocaÃ§Ãµes nas operaÃ§Ãµes Get/Set (~22-35ns/op)

## ğŸ³ Docker

O projeto inclui configuraÃ§Ã£o completa de Docker Compose.

### Arquitetura do Compose

```yaml
services:
  app:              # AplicaÃ§Ã£o Rate Limiter
  redis:            # Redis (backend de armazenamento)
  redis-insight:    # Redis Commander (interface web)
```

### Comandos Ãºteis

```bash
# Subir todos os serviÃ§os
docker-compose up -d

# Rebuild apÃ³s alteraÃ§Ãµes
docker-compose up -d --build

# Ver logs da aplicaÃ§Ã£o
docker-compose logs -f app

# Ver logs do Redis
docker-compose logs -f redis

# Parar todos os serviÃ§os
docker-compose down

# Parar e limpar volumes (dados do Redis)
docker-compose down -v

# Acessar shell do container
docker-compose exec app sh
```

### Portas expostas

- `8080`: AplicaÃ§Ã£o
- `6379`: Redis
- `8081`: Redis Commander (http://localhost:8081)

## ğŸ“ Exemplo de .env

```env
# Rate Limiting por IP
RATE_LIMITER_MAX_REQUESTS=100
RATE_LIMITER_TIME_DELAY=1m

# Rate Limiting por API Token
RATE_LIMITER_TOKEN_MAX_REQUESTS=200
RATE_LIMITER_TOKEN_TIME_DELAY=1m

# Cleanup AutomÃ¡tico
RATE_LIMITER_CLEANUP_INTERVAL=10m
RATE_LIMITER_TTL=1h
```

## ğŸ¤ Contribuindo

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/AmazingFeature`)
3. Commit suas mudanÃ§as (`git commit -m 'feat: Add some AmazingFeature'`)
4. Push para a branch (`git push origin feature/AmazingFeature`)
5. Abra um Pull Request

### Commits SemÃ¢nticos

Seguimos [Conventional Commits](https://www.conventionalcommits.org/):

- `feat:` Nova funcionalidade
- `fix:` CorreÃ§Ã£o de bug
- `docs:` MudanÃ§as na documentaÃ§Ã£o
- `test:` AdiÃ§Ã£o ou correÃ§Ã£o de testes
- `refactor:` RefatoraÃ§Ã£o de cÃ³digo
- `perf:` Melhoria de performance
- `chore:` Tarefas de manutenÃ§Ã£o

## ğŸ“„ LicenÃ§a

Este projeto foi desenvolvido como desafio tÃ©cnico para o curso de PÃ³s-GraduaÃ§Ã£o em Golang da FullCycle.

## ğŸ‘¨â€ğŸ’» Autor

Desenvolvido por Adalberto Fernandes Jr.

## ğŸ™ Agradecimentos

- FullCycle - PÃ³s-GraduaÃ§Ã£o Go Expert
- Comunidade Go Brasil

---

**Nota:** Este Ã© um projeto educacional desenvolvido para demonstraÃ§Ã£o de conceitos de rate limiting, concorrÃªncia e arquitetura limpa em Go.
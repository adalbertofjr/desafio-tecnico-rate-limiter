# Rate Limiter - Desafio TÃ©cnico FullCycle

[![Go Version](https://img.shields.io/badge/Go-1.23-blue.svg)](https://golang.org)
[![Tests](https://img.shields.io/badge/tests-53%20passing-brightgreen.svg)](https://github.com)
[![Coverage](https://img.shields.io/badge/coverage-100%25-brightgreen.svg)](https://github.com)
[![Architecture](https://img.shields.io/badge/pattern-Strategy-orange.svg)](https://refactoring.guru/design-patterns/strategy)

Middleware HTTP para controle de taxa de requisiÃ§Ãµes (rate limiting) desenvolvido em Go, com suporte a limitaÃ§Ã£o por IP e por token de API.

## ğŸ“‹ CaracterÃ­sticas

- âœ… **Rate limiting por IP**: Limita requisiÃ§Ãµes baseado no endereÃ§o IP do cliente
- âœ… **Rate limiting por API Key**: Limites independentes para requisiÃ§Ãµes autenticadas
- âœ… **Bloqueio automÃ¡tico**: IPs que excedem o limite sÃ£o bloqueados temporariamente
- âœ… **Cleanup automÃ¡tico**: Remove dados antigos periodicamente para gerenciar memÃ³ria
- âœ… **Thread-safe**: Implementado com `sync.RWMutex` para operaÃ§Ãµes concorrentes
- âœ… **Graceful shutdown**: Suporte a context para parada controlada
- âœ… **ConfigurÃ¡vel**: Todos os parÃ¢metros via variÃ¡veis de ambiente
- âœ… **IPv4 e IPv6**: Suporte completo para ambos protocolos
- âœ… **Strategy Pattern**: Backend plugÃ¡vel com interface para mÃºltiplas implementaÃ§Ãµes
- âœ… **In-memory storage**: Armazenamento local de alta performance com deep copy
- âœ… **Redis storage**: Backend Redis com serializaÃ§Ã£o JSON e thread-safety
- âœ… **ExtensÃ­vel**: FÃ¡cil adiÃ§Ã£o de novos backends (PostgreSQL, DynamoDB, etc.)

## ğŸš€ InstalaÃ§Ã£o

### PrÃ©-requisitos

- Go 1.23 ou superior
- Git
- Redis (opcional, apenas se usar RedisBackend)

### Clonar o repositÃ³rio

```bash
git clone https://github.com/seu-usuario/rate-limiter.git
cd rate-limiter
```

### Instalar dependÃªncias

```bash
go mod download
```

## âš™ï¸ ConfiguraÃ§Ã£o

Crie um arquivo `.env` na raiz do projeto:

```env
# ConfiguraÃ§Ãµes de Rate Limiting por IP
RATE_LIMITER_MAX_REQUESTS=100
RATE_LIMITER_TIME_DELAY=60s

# ConfiguraÃ§Ãµes de Rate Limiting por Token
RATE_LIMITER_TOKEN_MAX_REQUESTS=200
RATE_LIMITER_TOKEN_TIME_DELAY=60s

# ConfiguraÃ§Ãµes de Cleanup AutomÃ¡tico
RATE_LIMITER_CLEANUP_INTERVAL=10m
RATE_LIMITER_TTL=1h

# ConfiguraÃ§Ã£o do Backend (opcional)
RATE_LIMITER_BACKEND=memory  # ou 'redis'
RATE_LIMITER_REDIS_ADDR=localhost:6379
```

### VariÃ¡veis de Ambiente

| VariÃ¡vel | DescriÃ§Ã£o | Exemplo | PadrÃ£o |
|----------|-----------|---------|--------|
| `RATE_LIMITER_MAX_REQUESTS` | NÃºmero mÃ¡ximo de requisiÃ§Ãµes por IP | `100` | - |
| `RATE_LIMITER_TIME_DELAY` | Tempo de bloqueio apÃ³s exceder limite (IP) | `60s`, `5m`, `1h` | - |
| `RATE_LIMITER_TOKEN_MAX_REQUESTS` | NÃºmero mÃ¡ximo de requisiÃ§Ãµes por token | `200` | - |
| `RATE_LIMITER_TOKEN_TIME_DELAY` | Tempo de bloqueio apÃ³s exceder limite (token) | `60s`, `5m`, `1h` | - |
| `RATE_LIMITER_CLEANUP_INTERVAL` | Intervalo de execuÃ§Ã£o do cleanup | `10m`, `30m`, `1h` | - |
| `RATE_LIMITER_TTL` | Tempo de vida dos dados antes da limpeza | `1h`, `2h`, `24h` | - |
| `RATE_LIMITER_BACKEND` | Backend de armazenamento | `memory`, `redis` | `memory` |
| `RATE_LIMITER_REDIS_ADDR` | EndereÃ§o do servidor Redis | `localhost:6379` | - |

### Formatos de DuraÃ§Ã£o

O projeto aceita duraÃ§Ãµes no formato Go:
- `s` - segundos (ex: `30s`)
- `m` - minutos (ex: `5m`)
- `h` - horas (ex: `1h`)
- Combinados (ex: `1h30m`, `2h45m30s`)

## ğŸƒ Como Usar

### Iniciar o servidor

```bash
# Desenvolvimento
go run cmd/server/main.go

# Build e execuÃ§Ã£o
go build -o server cmd/server/main.go
./server
```

O servidor iniciarÃ¡ na porta **8080**.

### IntegraÃ§Ã£o em seu cÃ³digo

```go
package main

import (
    "context"
    "github.com/seu-usuario/rate-limiter/ajun"
    "github.com/seu-usuario/rate-limiter/ajun/middleware"
    "net/http"
    "time"
)

func main() {
    ctx := context.Background()
    
    // Configurar rate limiter
    config := ratelimiter.NewRateLimiterConfig(
        100,              // limite por IP
        time.Minute,      // delay de bloqueio IP
        200,              // limite por token
        time.Minute,      // delay de bloqueio token
        10*time.Minute,   // intervalo de cleanup
        1*time.Hour,      // TTL dos dados
    )
    
    // Criar router
    router := ajun.NewRouter(ctx)
    router.RateLimiter(config)
    
    // Adicionar handlers
    router.HandleFunc("/api/resource", yourHandler)
    
    // Iniciar servidor
    http.ListenAndServe(":8080", router.Handler)
}

// Exemplo com backend Redis
func mainWithRedis() {
    ctx := context.Background()
    
    // Criar backend Redis
    redisClient := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    redisBackend := ratelimiter.NewRedisBackend(ctx, redisClient)
    
    // Criar Storage com backend Redis
    storage := ratelimiter.NewStorage(
        ctx,
        redisBackend,           // Strategy Pattern em aÃ§Ã£o
        10*time.Minute,         // cleanup interval
        1*time.Hour,            // TTL
    )
    
    // Configurar rate limiter
    config := ratelimiter.NewRateLimiterConfig(
        100,              // limite por IP
        time.Minute,      // delay de bloqueio IP
        200,              // limite por token
        time.Minute,      // delay de bloqueio token
        10*time.Minute,   // intervalo de cleanup
        1*time.Hour,      // TTL dos dados
    )
    
    router := ajun.NewRouter(ctx)
    router.RateLimiter(config)
    // Storage com Redis serÃ¡ usado automaticamente
}
```

## ğŸ“¡ Exemplos de RequisiÃ§Ãµes

### RequisiÃ§Ã£o normal (sem token)

```bash
curl http://localhost:8080/health
```

Limitada por IP conforme `RATE_LIMITER_MAX_REQUESTS`.

### RequisiÃ§Ã£o com API Key

```bash
curl -H "Api_key: seu-token-aqui" http://localhost:8080/products
```

Limitada por token conforme `RATE_LIMITER_TOKEN_MAX_REQUESTS`.

### Resposta quando limite Ã© excedido

```
HTTP/1.1 429 Too Many Requests
Content-Type: text/plain

Too many requests
```

## ğŸ—ï¸ Arquitetura

### Estrutura de DiretÃ³rios

```
.
â”œâ”€â”€ ajun/                         # Framework/Router customizado
â”‚   â”œâ”€â”€ ajun.go                   # Router wrapper
â”‚   â”œâ”€â”€ ajun_test.go              # Testes de integraÃ§Ã£o
â”‚   â””â”€â”€ middleware/
â”‚       â””â”€â”€ ratelimiter/
â”‚           â”œâ”€â”€ ratelimiter.go    # LÃ³gica principal do rate limiter
â”‚           â”œâ”€â”€ ratelimiter_test.go
â”‚           â”œâ”€â”€ storage.go        # Camada de storage com cleanup
â”‚           â”œâ”€â”€ interface.go      # Backend interface (Strategy)
â”‚           â”œâ”€â”€ memory.go         # ImplementaÃ§Ã£o in-memory
â”‚           â”œâ”€â”€ memory_test.go    # Testes do backend memory
â”‚           â”œâ”€â”€ redis.go          # ImplementaÃ§Ã£o Redis
â”‚           â”œâ”€â”€ redis_test.go     # Testes do backend Redis
â”‚           â””â”€â”€ types.go          # ClientIPData struct
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ configs/
â”‚   â”‚   â””â”€â”€ configs.go            # Carregamento de configuraÃ§Ãµes
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go               # Entry point
â””â”€â”€ api/
    â””â”€â”€ health.http               # Exemplos de requisiÃ§Ãµes HTTP
```

### Componentes Principais

#### 1. **RateLimiter Middleware**

Intercepta requisiÃ§Ãµes HTTP e aplica controle de taxa baseado em:
- IP do cliente (`RemoteAddr`)
- Header `Api_key` (se presente)

#### 2. **Storage Layer**

Gerencia dados de rate limiting:
- Contador de requisiÃ§Ãµes por IP
- Timestamps de Ãºltima atividade
- Status de bloqueio (`DisableUntil`)
- IntegraÃ§Ã£o com backend via interface

#### 3. **Backend Interface (Strategy Pattern)**

Interface que define operaÃ§Ãµes de armazenamento:
```go
type Backend interface {
    Get(clientIP string) (*ClientIPData, error)
    Set(clientIP string, data *ClientIPData) error
    Delete(clientIP string) error
    List() (map[string]*ClientIPData, error)
    Clear() error
}
```

**ImplementaÃ§Ãµes disponÃ­veis:**
- `MemoryBackend`: In-memory com deep copy e thread-safety
- `RedisBackend`: Redis com serializaÃ§Ã£o JSON, mutex e miniredis para testes
- **Futuro**: `PostgreSQLBackend`, `DynamoDBBackend`, etc.

#### 4. **Cleanup Worker**

Goroutine background que executa periodicamente:
- Remove IPs sem atividade (baseado em TTL)
- Respeita bloqueios ativos
- Para gracefully com context

### Design Patterns

#### Strategy Pattern - Backend PlugÃ¡vel

O projeto implementa o **Strategy Pattern** para permitir diferentes estratÃ©gias de armazenamento sem alterar a lÃ³gica do rate limiter:

```go
// Interface Strategy
type Backend interface {
    Get(clientIP string) (*ClientIPData, error)
    Set(clientIP string, data *ClientIPData) error
    Delete(clientIP string) error
    List() (map[string]*ClientIPData, error)
}

// EstratÃ©gia Concreta 1: In-Memory
type MemoryBackend struct {
    mu   sync.RWMutex
    data map[string]*ClientIPData
}

// EstratÃ©gia Concreta 2: Redis
type RedisBackend struct {
    ctx    context.Context
    client *redis.Client
    mu     sync.RWMutex
}

// Context que usa a Strategy
type Storage struct {
    backend Backend  // <- ComposiÃ§Ã£o com interface
    // ... outros campos
}
```

**BenefÃ­cios:**
- âœ… **Open/Closed Principle**: Aberto para extensÃ£o, fechado para modificaÃ§Ã£o
- âœ… **Testabilidade**: Mock fÃ¡cil do backend para testes
- âœ… **Flexibilidade**: Trocar backend em runtime se necessÃ¡rio
- âœ… **SeparaÃ§Ã£o de responsabilidades**: Storage nÃ£o conhece detalhes de implementaÃ§Ã£o

**Como adicionar novo backend:**
```go
// 1. Implementar a interface Backend
type PostgreSQLBackend struct {
    db *sql.DB
}

func (p *PostgreSQLBackend) Get(clientIP string) (*ClientIPData, error) {
    // implementaÃ§Ã£o especÃ­fica do PostgreSQL
}
// ... implementar outros mÃ©todos

// 2. Usar no Storage
backend := NewPostgreSQLBackend(connStr)
storage := NewStorage(ctx, backend, cleanupInterval, ttl)

// Pronto! O resto do cÃ³digo continua funcionando
```

### Fluxo de Funcionamento

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Request   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RateLimiter        â”‚
â”‚  Middleware         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â–º Extrai IP
       â”œâ”€â–º Verifica Api_key header
       â”œâ”€â–º Incrementa contador
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Verifica se        â”‚
â”‚  estÃ¡ bloqueado     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â–º SIM: Retorna 429
       â”‚
       â””â”€â–º NÃƒO: Verifica limite
              â”‚
              â”œâ”€â–º Excedeu: Bloqueia + 429
              â”‚
              â””â”€â–º OK: Continua â”€â”€â–º Handler
```

## ğŸ§ª Testes

### Executar todos os testes

```bash
go test ./... -v
```

### Executar com cobertura

```bash
go test ./... -cover -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Executar com race detector

```bash
go test ./... -race
```

### Cobertura Atual

```
router:              100.0% âœ…
middleware/ratelimiter: 100.0% âœ…
storage:             100.0% âœ…
memory backend:      100.0% âœ…
redis backend:       100.0% âœ…
```

**Total: 53 testes**
- 11 testes de integraÃ§Ã£o (router)
- 18 testes unitÃ¡rios (ratelimiter)
- 12 testes de backend memory
- 12 testes de backend Redis (com miniredis)

**Benchmarks:**
- `BenchmarkMemoryBackend_Set`: ~35ns/op (0 alocaÃ§Ãµes)
- `BenchmarkMemoryBackend_Get`: ~22ns/op (0 alocaÃ§Ãµes)
- `BenchmarkMemoryBackend_ConcurrentSet`: ~202ns/op
- `BenchmarkMemoryBackend_ConcurrentGet`: ~110ns/op

### CenÃ¡rios Testados

- âœ… RequisiÃ§Ãµes abaixo do limite
- âœ… Bloqueio quando limite Ã© excedido
- âœ… Desbloqueio automÃ¡tico apÃ³s timeout
- âœ… IPs independentes
- âœ… ConcorrÃªncia (mÃºltiplas requisiÃ§Ãµes simultÃ¢neas)
- âœ… IPv4 e IPv6
- âœ… Limites diferentes para API Key
- âœ… Cleanup automÃ¡tico de dados antigos
- âœ… Graceful shutdown do cleanup worker
- âœ… Deep copy no backend para isolamento de dados
- âœ… Thread-safety testado com race detector
- âœ… Backend plugÃ¡vel via Strategy Pattern
- âœ… Redis backend com miniredis (testes sem servidor real)
- âœ… SerializaÃ§Ã£o/deserializaÃ§Ã£o JSON no Redis
- âœ… Clear() method para reset de dados nos testes

## ğŸ› ï¸ Desenvolvimento

### Tecnologias e PadrÃµes

- **Go 1.23**: Linguagem principal
- **Strategy Pattern**: Backend plugÃ¡vel e extensÃ­vel
- **sync.RWMutex**: Thread-safety com read/write locks
- **context.Context**: Controle de lifecycle e graceful shutdown
- **time.Ticker**: Cleanup periÃ³dico
- **Viper**: Gerenciamento de configuraÃ§Ãµes
- **httptest**: Testes HTTP
- **Deep Copy**: Isolamento de dados no backend
- **Redis**: Cliente go-redis/v9 com suporte a JSON
- **miniredis**: Mock in-memory do Redis para testes

### Executar em modo desenvolvimento

```bash
go run cmd/server/main.go
```

### Executar testes especÃ­ficos

```bash
# Apenas testes de middleware
go test ./ajun/middleware/ratelimiter -v

# Apenas testes do backend memory
go test ./ajun/middleware/ratelimiter -run TestMemoryBackend -v

# Apenas testes do backend Redis
go test ./ajun/middleware/ratelimiter -run TestRedis -v

# Teste especÃ­fico
go test ./ajun/middleware/ratelimiter -run TestRateLimiterHandler_BlocksRequestsAboveLimit -v

# Benchmarks do backend
go test ./ajun/middleware/ratelimiter -bench=BenchmarkMemoryBackend -benchmem
```

## ğŸ“Š Performance

### Benchmarks

```bash
go test ./ajun/middleware/ratelimiter -bench=. -benchmem
```

### Capacidade Estimada

- **Low-Medium traffic**: < 50k req/s âœ…
- **High traffic**: < 100k req/s âœ…
- **Very High traffic**: > 100k req/s (considerar Redis)

### OtimizaÃ§Ãµes Implementadas

- âœ… Mutex read/write separados (`RLock` vs `Lock`)
- âœ… Map lookup O(1)
- âœ… Cleanup assÃ­ncrono (nÃ£o bloqueia requisiÃ§Ãµes)
- âœ… Sem goroutines vazando (timer gerenciado)
- âœ… Deep copy apenas no `List()` (Get/Set sem alocaÃ§Ãµes extras)
- âœ… Backend interface sem overhead (chamadas diretas)
- âœ… Zero alocaÃ§Ãµes nas operaÃ§Ãµes Get/Set (~22-35ns/op)

## ğŸ³ Docker (Opcional)

### Dockerfile exemplo

```dockerfile
FROM golang:1.23-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN go build -o server cmd/server/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/server .
COPY .env .env
EXPOSE 8080
CMD ["./server"]
```

### Build e run

```bash
docker build -t rate-limiter .
docker run -p 8080:8080 --env-file .env rate-limiter
```

## ğŸ“ Exemplo de .env

```env
# Rate Limiting por IP
RATE_LIMITER_MAX_REQUESTS=100
RATE_LIMITER_TIME_DELAY=1m

# Rate Limiting por API Token
RATE_LIMITER_TOKEN_MAX_REQUESTS=200
RATE_LIMITER_TOKEN_TIME_DELAY=1m

# Cleanup AutomÃ¡tico
RATE_LIMITER_CLEANUP_INTERVAL=10m
RATE_LIMITER_TTL=1h
```

## ğŸ¤ Contribuindo

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/AmazingFeature`)
3. Commit suas mudanÃ§as (`git commit -m 'feat: Add some AmazingFeature'`)
4. Push para a branch (`git push origin feature/AmazingFeature`)
5. Abra um Pull Request

### Commits SemÃ¢nticos

Seguimos [Conventional Commits](https://www.conventionalcommits.org/):

- `feat:` Nova funcionalidade
- `fix:` CorreÃ§Ã£o de bug
- `docs:` MudanÃ§as na documentaÃ§Ã£o
- `test:` AdiÃ§Ã£o ou correÃ§Ã£o de testes
- `refactor:` RefatoraÃ§Ã£o de cÃ³digo
- `perf:` Melhoria de performance
- `chore:` Tarefas de manutenÃ§Ã£o

## ğŸ“„ LicenÃ§a

Este projeto foi desenvolvido como desafio tÃ©cnico para o curso de PÃ³s-GraduaÃ§Ã£o em Golang da FullCycle.

## ğŸ‘¨â€ğŸ’» Autor

Desenvolvido por Adalberto Fernandes Jr.

## ğŸ™ Agradecimentos

- FullCycle - PÃ³s-GraduaÃ§Ã£o Go Expert
- Comunidade Go Brasil

---

**Nota:** Este Ã© um projeto educacional desenvolvido para demonstraÃ§Ã£o de conceitos de rate limiting, concorrÃªncia e arquitetura limpa em Go.